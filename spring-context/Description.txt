Spring Framework — главным преимуществом является простота и легковесность.
Фреймворк Spring представляет собой контейнер Inversion of Control (IoC).


Inversion of Control (IoC, инверсия управления) — принцип ООП, согласнокоторому контроль над управлением элементом
программы (например, отдельным классом) передается от вас отдельному компоненту. Форм такого контроля может быть
множество, но Spring реализует одну из них — Dependency injection (DI, внедрение зависимостей).

Spring Context является реализацией IoC-контейнера, который берет на себя задачи создания объектов и внедрения зависимостей.

В упрощенном виде конфигурация Spring проходит в два этапа:
1) инициализация контекста;
2) создание, настройка, добавление компонентов (бинов) в контекст.

Виды конфигураций в Spring:
1) XML-конфигурация;
2) JavaConfig;
3) использование аннотаций @Component применяем для классов, написанных нами, @Bean - для стандартных классов

Spring обладает двумя самостоятельными способами конфигураций. А третий (использование аннотаций) может применяться
только на втором этапе совместно с одним из видов «самостоятельной» конфигурации. То есть можем применять:
1) либо XML-конфигурацию + использование аннотаций,
2) либо JavaConfig + использование аннотаций,
3) или два «самостоятельных» способа конфигурации без аннотаций.

<*******************************************************************************>
//todo вынести в пример
Пример конфигурирования с использованием XML - вынести в пакет !!!
Конфигурирование с использованием XML - создаём файл conf.xml
Создаём бин <bean id="cameraRoll" class="com.example.context.ColorCameraRoll" />
Создаём бин со ссылкой на другой бин
<bean id="cameraImpl" class="com.example.context.CameraImpl">
<property name="cameraRoll" ref="cameraRoll"/>
</bean>
<*******************************************************************************>

<*******************************************************************************>
//todo вынести в пример
Пример конфигурирования с использованием аннотаций - вынести в пакет !!!
Конфигурирование с использованием аннотаций
@Component("cameraRoll") -  Id бина указывается в аннотации в скобках.
<*******************************************************************************>

<*******************************************************************************>
//todo вынести в пример
Пример конфигурирования с использованием JavaConfig - вынести в пакет !!!
JavaConfig - Всю конфигурацию можно вынести в отдельный Java-класс, помеченный аннотацией @Configuration
<*******************************************************************************>

XML-конфигурация и JavaConfig являются двумя равнозначными способами конфигурации в Spring.
Но JavaConfig все же обладает весомыми преимуществами перед XML-конфигурацией:
1. Используется Java-код, а значит, не нужно заботиться о xsd-схемах и XML-тегах.
2. Можно выявить ошибки на этапе написания конфигурационного класса.
3. Больше гибкости за счет работы с объектами и методами.


Оптимальный способ — условие, согласно которому все бины, необходимые для инфраструктуры приложения (источники данных,
менеджеры транзакций), объявляются непосредственно в классе JavaConfig путем создания метода и применения к нему
аннотации @Bean. А ко всем классам, реализующим написанную нами бизнес-логику (либо к классам, предназначенным для
хранения какой-либо информации), применяются специальные аннотации (@Component, @Service, @Repository и т. п.)


Dependency Injection

Виды Dependency Injection:
1) внедрение через конструктор;
2) внедрение через сеттер;
3) внедрение на уровне поля.


Dependency Injection в Spring может осуществляться:
1) с помощью специальных тегов в XML-конфигурации;
2) с помощью методов в JavaConfig;
3) непосредственно в коде, используя аннотацию @Autowired.


Внедрение примитивных типов и строк (см. отдельный пример в этом модуле)
1) Через аннотацию @Value
2) Через конструктор
3) Через сеттер

Внедрение бинов
1) Через конструктор в xml
2) Через сеттер в xml
3) Через сеттер в JavaConfig
4) Через конструктор в JavaConfig
5) Через @Autowired в коде - эта аннотация может применяться к полю, сеттеру и конструктору


<*******************************************************************************>
//todo вынести в пример
вынести пример в пакет !!!
 * Через конструктор в xml
 * <constructor-arg ref="..." />
 *
 * Через сеттер в xml
 * <property name="cameraRoll">
 * <ref bean="cameraRoll" />
 * </property>
 *
 * Через сеттер в JavaConfig
 * @Bean(name = "cameraRoll")
 * public CameraRoll cameraRoll() {
 * return new ColorCameraRoll() ;
 * }
 * @Bean(name = "camera")
 * public Camera camera(CameraRoll cameraRoll) {
 * Camera camera = new CameraImpl();
 * camera.setCameraRoll(cameraRoll);
 * return camera;
 * }
 *
 * Через конструктор в JavaConfig
 * Чтобы сделать подобное через конструктор,
 * необходимо передать параметр cameraRoll в параметры оператора new (если класс имеет
 * конструктор с данной сигнатурой).
 *
 *  Через @Autowired - эта аннотация может применяться к полю, сеттеру и конструктору.
 *
 *  @Component("camera")
 * public class CameraImpl implements Camera {
 * private CameraRoll cameraRoll;
 * public CameraRoll getCameraRoll() {
 * return cameraRoll;
 * }
 * @Autowired
 * public void setCameraRoll(CameraRoll cameraRoll) {
 * this.cameraRoll = cameraRoll;
 * }
 * public void doPhotograph() {
 * System.out.println("Сделана фотография!");
 * cameraRoll.processing();
 * }
 * }
<*******************************************************************************>


Если в контексте есть несколько бинов заданного типа или бин не будет найден, то генерируется исключение
NoSuchBeanDefinitionException. В обоих случаях исключения можно избежать. Например, если атрибут required аннотации
@Autowired установить в значение false: @Autowired(required=false). Тогда в случае, если нужный бин отсутствует,
в элемент с данной аннотацией значение внедрено не будет.

Чтобы избежать исключения, когда в контексте имеется несколько бинов данного типа, необходимо использовать аннотацию
@Qualifier(“beanName”). Она позволяет указать id бина, который должен быть внедрен

@Primary - можем обозначить бин, который будет внедряться первостепенное, если есть несколько
//todo нужно добавить пример как работает @Qualifier и @Primary


Область видимости бинов

@Scope("singleton")  - Ограничивает одно определение компонента одним экземпляром объекта для каждого контейнера Spring IoC.

@Scope("prototype")  - Расширяет область действия одного определения компонента до любого количества экземпляров объекта.

@Scope("request")    - Ограничивает одно определение компонента жизненным циклом одного HTTP-запроса;
то есть каждый HTTP-запрос будет иметь свой собственный экземпляр компонента, созданный на основе одного определения компонента.
Допустимо только в контексте веб-приложения Spring ApplicationContext.

@Scope("session")    - Ограничивает одно определение компонента жизненным циклом HTTP-сеанса.
Допустимо только в контексте веб-приложения Spring ApplicationContext.

@Scope("global session") - Ограничивает одно определение компонента жизненным циклом глобального HTTP-сеанса.
Обычно допустимо только при использовании в контексте портлета. Допустимо только в контексте веб-приложения Spring ApplicationContext.

По умолчанию все компоненты Spring являются синглтонами @Scope("singleton"), и в большинстве ситуаций такой подходоптимален.



Этапы инициализации контекста
Весь процесс создания и инициализации бина делится на четыре этапа:

Этап 1. Производится чтение данных из конфигурационного файла. На основании полученных данных создаются специальные
объекты BeanDefinition, которые несут в себе информацию о бинах, которые надо создать. Эти объекты попадают в BeanFactory.

Этап 2. Производится настройка объектов класса BeanDefinition.

Этап 3. Производится конечная настройка созданных бинов (в том числе, внедрение зависимостей)

Этап 4. BeanFactory создает бины, используя информацию, хранящуюся в объектах BeanDefinition. На этапе 2 и 4 идёт
обработка большей части аннотаций Spring
//todo добавить примеры возможного изменеия на этапах 2 и 4 методичка 2 стр. 18 -23


Жизненный цикл бина
Все, что было рассмотрено ранее, относится к этапам инициализации контекста. Но сам бин об этих этапах ничего не знает.
Бины Spring обладают жизненным циклом. Фактически, это дает возможность вызывать собственные методы бина на его
жизненных этапах. Чтобы подобное стало возможным, необходимо как-то пометить метод и время его вызова.
На практике используется несколько подходов.

1) используем аннотации:
@PostConstruct – метод инициализации, вызываемый после создания объекта и внедрения зависимостей (т.е. между методами
postProcessBeforeInitialization и postProcessAfterInitialization интерфейса BeanPostProcessor);

@PreDestroy – метод, вызываемый перед уничтожением бина.

2) используем XML-атрибуты тега <bean>:
init-method
destroy-method

Оба подхода являются полными аналогами друг друга. Но если в вашем приложении используются оба подхода для одного и
того же бина, то первыми будут вызываться методы, помеченные аннотацией.
Применение этих аннотаций возможно благодаря поддержке Spring стандарта JSR-250.
Соответственно, для использования @PostConstruct и @PreDestroy необходимо подключать дополнительную зависимость.



<*******************************************************************************>
//todo вынести в пример
вынести пример в пакет !!!
 * В примере с фотокамерой реализуем метод инициализации, который выводит уведомление о том, что
 * фотоаппарат готов к использованию.
 * Чтобы использовать аннотации жизненного цикла (в частности, @PostConstruct), необходимо
 * добавить в файл pom.xml следующую зависимость:
 * <dependency>
 * <groupId>javax.annotation</groupId>
 * <artifactId>jsr250-api</artifactId>
 * <version>1.0</version>
 * </dependency>
 *
 * В интерфейсе Camera объявим новый метод:
 * public void ready();
 *
 * Реализуем этот метод в классе CameraImpl и пометим его аннотацией:
 * @Component("camera")
 * public class CameraImpl implements Camera {
 * @Autowired
 * private CameraRoll cameraRoll;
 * @Value("false")
 * private boolean broken;
 * public CameraRoll getCameraRoll() {
 * return cameraRoll;
 * }
 * public void setCameraRoll(CameraRoll cameraRoll) {
 * this.cameraRoll = cameraRoll;
 * }
 * public boolean isBroken() {
 * return broken;
 * }
 * public void breaking(){
 * this.broken = true;
 * }
 * public void doPhotograph(){
 * if (isBroken()) {
 * System.out.println("Фотоаппарат сломан!");
 * return;
 * }
 * System.out.println("Сделана фотография!");
 * cameraRoll.processing();
 * }
 * @PostConstruct
 * public void ready() {
 * System.out.println("Фотоаппарат готов к использованию!");
 * }
 * }
 *
 * При запуске клиентского кода получим оповещение о готовности к использованию. Данный метод
 * будет вызван между двумя методами интерфейса BeanPostProcessor.
 <*******************************************************************************>
