Главные преимущества Spring Framework:

1) Предоставляет реализацию принципа/паттерна преоктирования Inversion of Control и Dependency Injection.
Мы описываем каками должны быть объекты для работы нашего приложения, а Spring сам создаёт эти объекты и берёт на себя
управление этими объектами (их жизненный цикл и много другое). Все эти объекты хранятся в Spring application context -
контейнер Inversion of Control (IoC)
Spring сам внедряет все необходимые зависимости в объекты (связывает их между собой) (DI). Мы только описываем эту связь.

2) Spring Framework упрощяет работу с БД (Spring Data JPA -> Hibernate -> JDBC)
3) Упрощает создание Web приложений с помощью Spring Boot(более продвинутая версия Spring MVC, с кучей дефолтных преднастроек)
4) Spring Security
5) Spring Cloud и множество других

Inversion of Control (IoC, инверсия управления) — принцип ООП, согласнокоторому контроль над управлением элементом
программы (например, отдельным классом) передается от вас отдельному компоненту. Форм такого контроля может быть
множество, но Spring реализует одну из них — Dependency injection (DI, внедрение зависимостей).
Сущность не сама создаёт свои зависимости, а зависимости поставляются ей извне -> нпример, передаём через конструктор

Spring Context является реализацией IoC-контейнера, который берет на себя задачи создания объектов и внедрения зависимостей.

В упрощенном виде конфигурация Spring проходит в два этапа:
1) инициализация контекста;
2) создание, настройка, добавление компонентов (бинов) в контекст.

Зависимости для работы Spring приложения:
spring-core
spring-beans
spring-context

Бин - это просто Java объект, созданные Spring - ом, они так же создаются из Java классов, как и обычные объекты.

Виды конфигураций в Spring:
1) XML-конфигурация - позволяет изменять зависимости и бины без перекомпеляции приложения;
2) JavaConfig;
3) использование аннотаций @Component применяем для классов, написанных нами, @Bean - для стандартных классов

Spring обладает двумя самостоятельными способами конфигураций. А третий (использование аннотаций) может применяться
только на втором этапе совместно с одним из видов «самостоятельной» конфигурации. То есть можем применять:
1) либо XML-конфигурацию + использование аннотаций,
2) либо JavaConfig + использование аннотаций,
3) или два «самостоятельных» способа конфигурации без аннотаций.

<*******************************************************************************>
//todo вынести в пример
Пример конфигурирования с использованием XML - вынести в пакет !!!
Конфигурирование с использованием XML - создаём файл conf.xml
Создаём бин <bean id="cameraRoll" class="com.example.context.ColorCameraRoll" />
Создаём бин со ссылкой на другой бин
<bean id="cameraImpl" class="com.example.context.CameraImpl">
<property name="cameraRoll" ref="cameraRoll"/>
</bean>
<*******************************************************************************>

<*******************************************************************************>
//todo вынести в пример
Пример конфигурирования с использованием аннотаций - вынести в пакет !!!
Конфигурирование с использованием аннотаций
@Component("cameraRoll") -  Id бина указывается в аннотации в скобках.
<*******************************************************************************>

<*******************************************************************************>
//todo вынести в пример
Пример конфигурирования с использованием JavaConfig - вынести в пакет !!!
JavaConfig - Всю конфигурацию можно вынести в отдельный Java-класс, помеченный аннотацией @Configuration
<*******************************************************************************>

XML-конфигурация и JavaConfig являются двумя равнозначными способами конфигурации в Spring.
Но JavaConfig все же обладает весомыми преимуществами перед XML-конфигурацией:
1. Используется Java-код, а значит, не нужно заботиться о xsd-схемах и XML-тегах.
2. Можно выявить ошибки на этапе написания конфигурационного класса.
3. Больше гибкости за счет работы с объектами и методами.


Оптимальный способ — условие, согласно которому все бины, необходимые для инфраструктуры приложения (источники данных,
менеджеры транзакций), объявляются непосредственно в классе JavaConfig путем создания метода и применения к нему
аннотации @Bean. А ко всем классам, реализующим написанную нами бизнес-логику (либо к классам, предназначенным для
хранения какой-либо информации), применяются специальные аннотации (@Component, @Service, @Repository и т. п.)

Когда используем аннотации Spring сканирует все классы и находит классы со специальными аннотациями и автоматически
создаёт бины из этих классов

@Component - Помечаем ей класс, если хотим, чтобы Spring создал из него бин, имеено эту аннотацию ищет спринг, когда сканирует классы,
можно указать id для создаваемого бина, если не казваем, то имя будет название_класса_с_маленькой_буквы

@Autowired - внедрение бинов (DI). Spring  сканирует все классы с анотацией @Component и создаёт бины из этих классов.
Spring сканирует все созданные бины и проверяет, подходит ли хотя бы один бин в качестве зависимости там, где мы указали
аннотацию @Autowired.
Если находится один подходящий бин, он внедряется в качестве зависимости.
Если не находится ни одного бина - ошибка
Если находятся несколько подходящих бинов - неоднозначность

@Qualifier("rockMusic") - аннотация, которая убирает неоднозначность указываем id бина, который необходимо внедрить.
Эту аннотация можно импользовать на полях, конструкторах и сеттерах. При внедрении в конструктор необходимо использовать
немного другой синтаксис - например
@Autowired
public MusicPlayer(@Qualifier("rockMusic") Music music){
this.music=music;
}

Если в контексте есть несколько бинов заданного типа или бин не будет найден, то генерируется исключение
NoSuchBeanDefinitionException. В обоих случаях исключения можно избежать. Например, если атрибут required аннотации
@Autowired установить в значение false: @Autowired(required=false). Тогда в случае, если нужный бин отсутствует,
в элемент с данной аннотацией значение внедрено не будет.

Чтобы избежать исключения, когда в контексте имеется несколько бинов данного типа, необходимо использовать аннотацию
@Qualifier(“beanName”). Она позволяет указать id бина, который должен быть внедрен

@Primary - можем обозначить бин, который будет внедряться первостепенное, если есть несколько
//todo нужно добавить пример как работает @Primary

Можем внедрять бины по конкретному классу или по интерфейсу
Виды внедрения зависимостей (Dependency Injection):
1) внедрение через конструктор;
2) внедрение через сеттер;
3) внедрение на уровне поля.

Внедрение через поле. Аннотация @Autowired внедрит зависимость в приватное поле даже если нет конструктора или сеттара. Делает она это с помощью
рефлексии (Java Reflection API)

Dependency Injection - значит что один объект зависит от второго, имеет ссылку на другой объект, необходим другой
объект для работы.

Dependency Injection в Spring может осуществляться:
1) с помощью специальных тегов в XML-конфигурации;
2) с помощью методов в JavaConfig;
3) непосредственно в коде, используя аннотацию @Autowired.


Внедрение примитивных типов и строк (см. отдельный пример в этом модуле)
1) Через аннотацию @Value
2) Через конструктор
3) Через сеттер

Внедрение бинов
1) Через конструктор в xml
2) Через сеттер в xml
3) Через сеттер в JavaConfig
4) Через конструктор в JavaConfig
5) Через @Autowired в коде - эта аннотация может применяться к полю, сеттеру и конструктору


<*******************************************************************************>
//todo вынести в пример
вынести пример в пакет !!!
 * Через конструктор в xml
 * <constructor-arg ref="..." />
 *
 * Через сеттер в xml
 * <property name="cameraRoll">
 * <ref bean="cameraRoll" />
 * </property>
 *
 * Через сеттер в JavaConfig
 * @Bean(name = "cameraRoll")
 * public CameraRoll cameraRoll() {
 * return new ColorCameraRoll() ;
 * }
 * @Bean(name = "camera")
 * public Camera camera(CameraRoll cameraRoll) {
 * Camera camera = new CameraImpl();
 * camera.setCameraRoll(cameraRoll);
 * return camera;
 * }
 *
 * Через конструктор в JavaConfig
 * Чтобы сделать подобное через конструктор,
 * необходимо передать параметр cameraRoll в параметры оператора new (если класс имеет
 * конструктор с данной сигнатурой).
 *
 *  Через @Autowired - эта аннотация может применяться к полю, сеттеру и конструктору.
 *
 *  @Component("camera")
 * public class CameraImpl implements Camera {
 * private CameraRoll cameraRoll;
 * public CameraRoll getCameraRoll() {
 * return cameraRoll;
 * }
 * @Autowired
 * public void setCameraRoll(CameraRoll cameraRoll) {
 * this.cameraRoll = cameraRoll;
 * }
 * public void doPhotograph() {
 * System.out.println("Сделана фотография!");
 * cameraRoll.processing();
 * }
 * }
<*******************************************************************************>


Область видимости бинов

@Scope("singleton")  - Ограничивает одно определение компонента одним экземпляром объекта для каждого контейнера Spring IoC.
Чаще всего используется тогда, когда у нашего бина нет изменяемых состояний (stateless)

@Scope("prototype")  - Расширяет область действия одного определения компонента до любого количества экземпляров объекта.
Чаще всего используется тогда, когда у нашего бина есть изменяемые состояния (stateful)

@Scope("request")    - Ограничивает одно определение компонента жизненным циклом одного HTTP-запроса;
то есть каждый HTTP-запрос будет иметь свой собственный экземпляр компонента, созданный на основе одного определения компонента.
Допустимо только в контексте веб-приложения Spring ApplicationContext.

@Scope("session")    - Ограничивает одно определение компонента жизненным циклом HTTP-сеанса.
Допустимо только в контексте веб-приложения Spring ApplicationContext.

@Scope("global session") - Ограничивает одно определение компонента жизненным циклом глобального HTTP-сеанса.
Обычно допустимо только при использовании в контексте портлета. Допустимо только в контексте веб-приложения Spring ApplicationContext.

По умолчанию все компоненты Spring являются синглтонами @Scope("singleton"), и в большинстве ситуаций такой подход оптимален.



Этапы инициализации контекста
Весь процесс создания и инициализации бина делится на четыре этапа:

Этап 1. Производится чтение данных из конфигурационного файла. На основании полученных данных создаются специальные
объекты BeanDefinition, которые несут в себе информацию о бинах, которые надо создать. Эти объекты попадают в BeanFactory.

Этап 2. Производится настройка объектов класса BeanDefinition.

Этап 3. Производится конечная настройка созданных бинов (в том числе, внедрение зависимостей)

Этап 4. BeanFactory создает бины, используя информацию, хранящуюся в объектах BeanDefinition. На этапе 2 и 4 идёт
обработка большей части аннотаций Spring
//todo добавить примеры возможного изменеия на этапах 2 и 4 методичка 2 стр. 18 -23


Жизненный цикл бина
Все, что было рассмотрено ранее, относится к этапам инициализации контекста. Но сам бин об этих этапах ничего не знает.
Бины Spring обладают жизненным циклом. Фактически, это дает возможность вызывать собственные методы бина на его
жизненных этапах. Чтобы подобное стало возможным, необходимо как-то пометить метод и время его вызова.
На практике используется несколько подходов.

Запуск приложения -> Запуск Spring контейнера -> Создание объекта бина -> в бин внедряются зависимости (DI) ->
вызывается указанный init - method -> бин готов к использованию -> работа приложения ->
вызывается указанный destroy - method -> остановка Spring приложения

init - method - запускается в ходе инициализации бина, обычно используется для инициализации ресурсов,
обращения к внешним файлам, запуска БД

destroy-method - запускается в ходе уничтожения бина (при завершении приложения), обычно используется для освобождения
ресурсов, закрытия потоков ввода-вывода, закрытия доступа к БД

У этих двух методов может быть любой модификатор доступа (private, public, protected)
Обычно возвращаемое значение void так как мы не можем получить возвращаемое значение, название метода может быть любым,
эти методы не должны принимать на вход какие-либо аргументы
Для бинов со scope "prototype" Spring не вызывает метод destroy
Spring не берёт на себя полный жизненный цикл бинов со scope "prototype". Spring отдаёт prototype бины клиенту и больше
о них не заботится (в отличае от singleton бинов)

factory-method - если объекты класса создаются фабричным методом, то можно определить factory-method
Для этого в этом классе, нужно создать приватный конструктор и статический фабричный метод, который будет возвращать
объект класса. Далее в конфигурации бина помечаем, что у него есть фабричный метод и передаём его название. В данном
случае, сколько бы мы раз не вызвали фабричный метод, ссылка будет на один и тот же объект (всё равно будет scope singleton).
При каждом вызове метода getBean Spring будет один раз создавать объект, а потом всё время возвращать ссылку на него.


1) используем аннотации:
@PostConstruct – метод инициализации, вызываемый после создания объекта и внедрения зависимостей (т.е. между методами
postProcessBeforeInitialization и postProcessAfterInitialization интерфейса BeanPostProcessor);

@PreDestroy – метод, вызываемый перед уничтожением бина.

2) используем XML-атрибуты тега <bean>:
init-method
destroy-method

Оба подхода являются полными аналогами друг друга. Но если в вашем приложении используются оба подхода для одного и
того же бина, то первыми будут вызываться методы, помеченные аннотацией.
Применение этих аннотаций возможно благодаря поддержке Spring стандарта JSR-250.
Соответственно, для использования @PostConstruct и @PreDestroy необходимо подключать дополнительную зависимость.



<*******************************************************************************>
//todo вынести в пример
вынести пример в пакет !!!
 * В примере с фотокамерой реализуем метод инициализации, который выводит уведомление о том, что
 * фотоаппарат готов к использованию.
 * Чтобы использовать аннотации жизненного цикла (в частности, @PostConstruct), необходимо
 * добавить в файл pom.xml следующую зависимость:
 * <dependency>
 * <groupId>javax.annotation</groupId>
 * <artifactId>jsr250-api</artifactId>
 * <version>1.0</version>
 * </dependency>
 *
 * В интерфейсе Camera объявим новый метод:
 * public void ready();
 *
 * Реализуем этот метод в классе CameraImpl и пометим его аннотацией:
 * @Component("camera")
 * public class CameraImpl implements Camera {
 * @Autowired
 * private CameraRoll cameraRoll;
 * @Value("false")
 * private boolean broken;
 * public CameraRoll getCameraRoll() {
 * return cameraRoll;
 * }
 * public void setCameraRoll(CameraRoll cameraRoll) {
 * this.cameraRoll = cameraRoll;
 * }
 * public boolean isBroken() {
 * return broken;
 * }
 * public void breaking(){
 * this.broken = true;
 * }
 * public void doPhotograph(){
 * if (isBroken()) {
 * System.out.println("Фотоаппарат сломан!");
 * return;
 * }
 * System.out.println("Сделана фотография!");
 * cameraRoll.processing();
 * }
 * @PostConstruct
 * public void ready() {
 * System.out.println("Фотоаппарат готов к использованию!");
 * }
 * }
 *
 * При запуске клиентского кода получим оповещение о готовности к использованию. Данный метод
 * будет вызван между двумя методами интерфейса BeanPostProcessor.
 <*******************************************************************************>

@Configuration - аннотация для обозначения класса (бина) с конфигурацией, аналогичный функционалу конфигурационному файлу в XML
@ComponentScan("com.example.context.annotation.example_15_value_scope_postconstruct_predestroy") = тэгу component-scan в xml