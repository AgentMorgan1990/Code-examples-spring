package com.example.context;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 *  Spring Framework — главным преимуществом которого является простота и легковесность. Фреймворк Spring
 * представляет собой контейнер Inversion of Control (IoC).
 *
 * Inversion of Control (IoC, инверсия управления) — принцип ООП, согласно
 * которому контроль над управлением элементом программы (например, отдельным классом)
 * передается от вас отдельному компоненту. Форм такого контроля может быть множество, но Spring
 * реализует одну из них — Dependency injection (DI, внедрение зависимостей).
 *
 * Spring Context является реализацией IoC-контейнера, который берет на себя задачи создания
 * объектов и внедрения зависимостей.
 *
 * В упрощенном виде конфигурация Spring проходит в два этапа:
 * ● инициализация контекста;
 * ● создание, настройка, добавление компонентов (бинов) в контекст.
 *
 * Виды конфигураций в Spring:
 * ● XML-конфигурация;
 * ● JavaConfig;
 * ● использование аннотаций
 *
 * Spring обладает двумя самостоятельными способами конфигураций. А
 * третий (использование аннотаций) может применяться только на втором этапе совместно с одним из
 * видов «самостоятельной» конфигурации. То есть можем применять:
 * ● либо XML-конфигурацию + использование аннотаций,
 * ● либо JavaConfig + использование аннотаций,
 * ● или два «самостоятельных» способа конфигурации без аннотаций.
 *
 * Конфигурирование с использованием XML - создаём файл conf.xml
 * Создаём бин <bean id="cameraRoll" class="com.example.context.ColorCameraRoll" />
 * Создаём бин со ссылкой на другой бин
 * <bean id="cameraImpl" class="com.example.context.CameraImpl">
 *   <property name="cameraRoll" ref="cameraRoll"/>
 * </bean>
 *
 * Конфигурирование с использованием аннотаций
 * @Component("cameraRoll") -  Id бина указывается в аннотации в скобках.
 *
 * JavaConfig - Всю конфигурацию можно вынести в отдельный Java-класс, помеченный аннотацией @Configuration
 *
 * XML-конфигурация и JavaConfig являются двумя равнозначными способами конфигурации в Spring.
 * Но JavaConfig все же обладает весомыми преимуществами перед XML-конфигурацией:
 * 1. Используется Java-код, а значит, не нужно заботиться о xsd-схемах и XML-тегах.
 * 2. Можно выявить ошибки на этапе написания конфигурационного класса.
 * 3. Больше гибкости за счет работы с объектами и методами.
 *
 * Оптимальный способ — условие, согласно которому все бины, необходимые для инфраструктуры
 * приложения (источники данных, менеджеры транзакций), объявляются непосредственно в классе
 * JavaConfig путем создания метода и применения к нему аннотации @Bean. А ко всем классам,
 * реализующим написанную нами бизнес-логику (либо к классам, предназначенным для хранения
 * какой-либо информации), применяются специальные аннотации (@Component, @Service, @Repository и т. п.)
 *
 * Виды Dependency Injection:
 * ● внедрение через конструктор;
 * ● внедрение через сеттер;
 * ● внедрение на уровне поля.
 *
 * Dependency Injection в Spring может осуществляться:
 * ● с помощью специальных тегов в XML-конфигурации;
 * ● с помощью методов в JavaConfig;
 * ● непосредственно в коде, используя аннотацию @Autowired.
 *
 * Внедрение примитивных типов и строк (см. отдельный пример в этом модуле)
 *  Через аннотацию @Value
 *  Через конструктор
 *  Через сеттер
 *
 * Внедрение бинов
 *
 *
 *
 *
 *
 * */

//todo разобрать методичку с 13 страницы

//todo разобрать примеры внедрения разныз бинов в один интерфейс @Qualifier @Primary

//todo примеры стратегий создания бинов

//todo добавить примеры из лекции, для расширения вариантов

//todo подумать как читаемо разнести примеры и объяснения в этом модуле

public class Client {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("config.xml");
        Camera camera = context.getBean("camera", Camera.class);
        camera.doPhotograph();
    }
}
