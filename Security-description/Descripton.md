Spring Security — это мощный и гибкий фреймворк, предоставляющий механизмы защиты веб-приложения. Предлагает несколько
уровней защиты:
1) защита на уровне запросов — ограничение доступа к ресурсам, имеющим определенный URL;
2) защита на уровне представлений — отображение элементов представления в зависимости от привилегий пользователя;
3) защита на уровне методов — ограничение вызова методов сервисов/контроллеров в зависимости от привилегий пользователя.

@Configuration говорит о том, что данный класс является конфигурационным.

@EnableWebSecurity отключает стандартные настройки безопасности Spring Security и начинает использовать правила,
прописанные в SecurityConfig.

@EnableGlobalMethodSecurity активирует возможность ставить защиту на уровне методов (для этого над методами ставятся
аннотации @Secured и @PreAuthorized).

Защита на уровне представлений

Защита на уровне методов
Последний шаг для создания надежной защиты приложения — ограничить доступ на уровне методов. Для этого можно
использовать аннотацию @Secured, которая ограничивает доступ к отдельным методам на основе информации о правах
текущего пользователя.


Сессия с сайтом
В бразузере есть файл cookies в который кладётся JSessionId, если такого файла нет, сервер присылает браузеру в хеддере
set-cookie:JSessionId = ....  и браузер зашивает для этого сайта ключ-значение JSessionId. Всё что записано в cookies
будет всё время отправляться сайту, пока не почистим cookies. Если долго не заходим на сайт JSessionId протухает.
Само Java приложение не занимается разбором cookies, этим занимается applicationServer - в данном случае TomCat.
SpringSecurityFilterChain - цепочка фильтров, которая определяет можем ли мы стучаться в определённые эндпоинты.
Если хотим достучаться до эндпоинта с необходимой авторизаций один из фильтров может нас перенаправить на страницу
с авторизацией или просто отправить 401 статус код, пользователь может быть авторизован, но недостаточные права
на доступ этому эндпоиту, возвращаем 403

SpringSecurityContext живёт в SpringSecurityContextHolder-е, этот контекст подвязывает наш JSessionId к объекту(UserDetails)
в котором лежит username, password и authorities.
Authorities - это List<String> в котором лежат название ролей или прав, например
ROLE_ADMIN, ROLE_MANAGER. На эндпоинтах можем указывать с какой ролью можно в него стучаться, например .hasRole("ADMIN")
При первом обращении на сайт, нас нет в контексте, клиентуьотправляется запрос на авторизацию, когда прилетает логин и
пароль создаётся объект UsernameAndPasswordAuthenticationToken, который содержит логин и пароль, этот объект отправляется
в AuthenticationProvider, который должен определить валидность данных, для этого он идёт в UserDetailsService у которого
две задачи 1) найти пользователя и извлечь его (Например, они могут хранится в БД, в памяти в файле и т.д.),
2) Преобразовать нашего юзера в читаемую для спринга форму -> UserDetails , далее они отдаются обратно в
AuthenticationProvider, который сравнивает полученные данные от клиента и данные из UserDetailsService методом authenticate,
если пользователь прошёл аутентификацию AuthenticationProvider кладёт UserDetails в SpringSecurityContext вместе с JSessionId,
но при этом в контексте зачищаются пароли.

Роль разработчика - настройка бина UserDetailsService, остальное это внутренности спринга.
Хотя сам AuthenticationProvider можно настраивать

Пример заполнения БД с юзерами и ролями в V1__init.sql
Пароль в таблице лежит в виде хэша, с помощью хэширования BCrypt чтобы зашифровать что-то можно воспользоваться декриптором в интеренете
Пример конфигурации UserDetailsService -> UserDetailsService в этот сервис имплементим, место где хранятся юзеры, в этом примере БД
Необходимо реализовать метод loadUserByUsername найти юзера и преобразовать в понятную спрингу форму UserDetails
GrantedAuthority - это обёртка над строкой - по сути контракт

Далее проводим настройку безопасности в классе SecurityConfig - пример настройки AuthenticationProvider
DaoAuthenticationProvider - преднастроенный провайдер для БД, если хотим изменить место храннения надо воспользоваться
другим провайдером

Пример такой настроики форм работает при связке фронта и бэка на спринге, это форма логирования спринговая , на реальных
проектах применяем немного другую настройку форм.

Существует два варианта настройки доступа:
1) по ролям .hasAnyRole("ADMIN")
2) по правам .hasAnyAuthority("Read")

Для настройки роли надо дописать в префикс ROLE_ - в примере храним в БД ROLE_ADMIN, но при конфигурировании пишем только "ADMIN"
Этот префикс нужен только для возможности отличить роль от права
Конфигурировать их мы можем как нам удобнее (можем использовать либо роли, либо права, либо и то и другое), например,
один из вариантов - назначить каждой роли разные права.

В Principal - записываются данные о юзере - пример в контроллере DemoController

Пример security без использования БД в памяти в spring-security-inmemory

Пример конфигурирования в БД spring-security-jdbc - с простой настройкой, если следовать заполнению таблиц из документации спринга

Для REST API применяется другой алгоритм безопасности , т.к. каждый запрос должен быть изолирован. 
Базовая аутентификация (Basic Auth) - можем отправлять логин и пароль при каждом запросе, но это не очень безопасно.

В данном случае лучше применять технологию c использованием JWT.
Отправляем на сервер авторизации логин и пароль и получаем токен, далее по эндпоинтам ходим с этим токеном - в данном 
случае мы будем использовать JWT (Json Web Token). 

JWT (Json Web Token)
Получение токена проводится на отдельном незащищённом эндпоинте. Токен может находится в
закодированном виде в хеддере написан алгоритм подписи.
Токен делится на 3 части - header, payload, verify signature. В payload находятся разнообразные данные, например
права доступа и т.п., время жизни токена, id токена. Токен зашифрован в Base64. Далее токен прогоняется через алгоритм 
хэширования, для хэштрования используется специальный ключ, который подписывается в verify signature. Ключ хранится на 
сервере и он сравнивает, не было ли подмены данных в хеддере или пайлоад. Токен подшивается в хеадер Authorization запроса,
например Bearer.
Для реализации такого алгоритма мы модифицируем один из фильтров в SpringSecurityFilterChain чтобы он проверял токен и
при успешной проверке закидывал в SpringSecurityContext userDetails, после того как запрос будет обработан, пользователь
удаляется из SpringSecurityContext. Этот фильтр должен быть первым, чтобы последующие фильтры уже видели информацию в userDetails.


