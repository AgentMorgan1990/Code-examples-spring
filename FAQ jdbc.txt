Тема 4 (JDBC):

1. Что такое JDBC?
Java database connectivity - нужен для взаимодейсвия приложения в БД.

2. Зачем нужен JDBC драйвер?
Драйвер реализует интерфейс для конкретной БД.

3. Назовите часто используемые интерфейсы JDBC? Зачем нужен каждый из них?
interface Connection - хранит в себе состояние подключения в базе данных
interface Statement - позволяет посылать запросы в базу данных
interface ResultSet - набор данных, которая БД нам вернула. Объектное предсталенние реляционных данных из БД.
class DriverManager -

4. Можно ли подключить несколько JDBC драйверов?
Да, никаких ограничений нет. Можем зарегистировать сколько угодно драйверов и пользоваться ими при необходимости.
В современных приложениях встречается это довольно часто.

5. Зачем нужен DriverManager?
Специализированный класс по управлению JDBC - драйверами
Содержит набор методов для регистрации драйверов и разрегистрации драйверов, позволяет запросить подключение
к зарегистрированным драйверам. Все мктоды статические, поэтому создать экземпляр DriverManager-а создать нельзя

6. Откуда берется имя драйвера и url для подключения к БД?
Из документации к этой БД. Если говорим о том, где хранятся настройки в приложении, то это либо сам код,
либо проперти и передаются в драйвер менеджер

7. Чем Statement.executeUpdate() отличается от Statement.executeQuery()?
В оба можно положить любой SQL запрос.
Statement.executeUpdate() - возвращает интовое значение с количеством обновлённых строк, соответственно помещаем всё,
кроме SELECT-ов
Statement.executeQuery() - возвращает сущность, из которой можно получить данные, соответственно помещаем сюда SELECT-ы

8. Если мы используем Hibernate или Spring Data JPA задействуется ли хоть как-то JDBC?
Да, Hibernate обёртка над JDBC, а Spring Data JPA обёртка над Hibernate.
JDBC-> Hibernate-> Spring Data JPA

9. Как на уровне JDBC управлять открытием и фиксацией транзакций?
commit
autocommit
rollback
здесь же можно задать уровень изоляции параллельных транзакций
При создании нового коннекшена стоит флаг автокомит true и соответственно, каждое обращение в базу автоматически коммитится.
Если необходимо вручную управлять транзакциями - autocommit - false, проводим операции, далее commit или rollback,
чтобы откатить или можно опять включить autocommit - true

10. Зачем выполнять Class.forName()?
Регистрируем драйвер базы данных, загружая класс в метаспейс с помощью class loader.
Существует ещё статический метод ригистр драйвер у драйвер менеджера. Сейчас этот подход устарел,
т.к. драйвера регистрируются автоматически и вручную их инициализировать не нужно

11. Что такое транзакция?
Некий набор действий (сущность), которые должны выполнится либо все, либо не выполниться вообще, не может быть выполнена наполовину.

12. Назовите свойства транзакций (ACID)
Atomicity Атомарность - транзакция неделима либо
Consistency Согласованность - не нарушается консистентность базы данных (не дублируются ключи, не происходит удаления ссылок, на
которые ссылаются другие объекты(каскадное удаление))
Isolation  Изолированность - одна транзакция не должна влиять на другие транзакции при параллельном исполнении
Durability Долговечность/Надёжность  - после того, как транзакция была зафиксирована, если даже упадёт сервер, отключится
свет и т.д. данные не потеряютяся (решается в основном путём сохранения в энергонезависимой памяти), этот пункт обычно
сильнее всего влият на производительность БД т.к. надо записать данные куда-то.

13. Какие проблемы параллельных транзакций вы можете назвать?
Lost update - потерянная транзакция, записывается только последняя транзакция, очень похоже на пример race condition,
две операции делают гет, прибавляют какое-то число, сначала записывается первая, а потом записывапется вторая, и данные первой теряются.
Dirty read - одна транзакция вносит изменения в поле, но ещё не окммитит изменения, в это время вторая транзакция забирает
уже обновлённые данные и проводит операции с ними, при этом первая транзакция делает ролбэк.
Non-repeatable read - производим повторного чтения - например первая транзакция вычислет максимальное число в ряду,
а вторая транзакция вносит изменения в эти значения и итогом первой транзакции будет некорректное вычисление.
Отличие от грязного чтения, что игнорируется данные в процессе вычисления, какие-то строки строки обновляются,
а транзакция не обращает на это внимание.
Fantom reads - очень схоже в повторным чтением, но тут строки не изменяются, а могут быть добавлены или удалены

14. Какие уровни изоляции транзакций бывают и что они дают?
Read uncommitted решает (Lost update) - самая быстрая, можно пользоваться например для вывода данных на аналитический
дашбор, на котором данные быстро обновляются
Read committed решает (Lost update, Dirty read) - во многих СУБД по умолчанию стоит именно этот уровень
Repeatable read решает (Lost update, Dirty read, Non-repeatable read) - проверяет изменения уже прочитанных колонок,
либо перевычитает строки, либо заблокирует изменения этих строк в зависимости от реализации СУБД
Serializable решает (Lost update, Dirty read, Non-repeatable read,Fantom reads) - по факту это блокировка всей таблицы,
если транзакция работает с таблицей, другие таблицы не могут этого делать

15. Если мы используем пакетную отправку запросов, надо ли отключать авто-коммит для повышения
скорости выполнения запросов?
Да, т.к. если будем фиксировать каждую транзакцию можем очень сильно снизить производительность системы.