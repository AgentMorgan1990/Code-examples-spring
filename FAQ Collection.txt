Тема 2 (Коллекции):

1. Как устроен ArrayList?
Динамический (Саморасширяющийся) массив, обёртка на классическим массивом.
Содержит переменную size, которая показывает сколько ячеек заполнено.
Default capacity = 10.
Если ArrayList заполнен, создается новый лист в 1,5 раза больше.
Ограничение размера ArrayList по количеству ресурсов или размером int 32 млрд. т.к. size интовое значение.
Может только увеличиваться и не уменьшается, даже если мы из него уберём все элементы.

2. Можно ли из ArrayList в каком-то случае достать null?
При создании ArrayList все значения инициализирутся null, но в таком случае вытащить не можем, т.к. size = 0
Но если мы сами положим в ArrayList null, то size увеличится, и можно будет вытащить null.

3. Вряд ли такое спросят: почему метод ArrayList.add() имеет тип boolean?
Только одна функция add(E element) возвращают boolean, при этом возвращает всегда true.
Остальные, например add(int index, E element) - войдовский.
Сделано так, потому что метод add() наследуется от интерфейса Collection, а этот метод используется не только в ArrayList.
Например в Set, есть логичное его использование, смогли добавить или нет.

4. Как устроен LinkedList?
Двусвязный список, состоит из нод, которые хранят значение и ссылки на следующую и предыдущую ноду.
В самом LinkedList - хранится первый и последний элемент.
В LinkedList в Java невозможно получить ссылку на наду и поэтому, если нам надо удалять несколько элеметов подряд,
необходимо использовать итератор, чтобы каждый раз не искать этот элемент перебором

5. Как LinkedList выполняет поиск по индексу? Или он не умеет это делать?
Да, т.к. это наследник интерфейса List, в котором есть метод get(int index), но реализовано перебором всех значения
по порядку со сложностью O(n/2) -> O(n) , т.к. может сначала определить с какой стороны быстрее перемещаться,
т.к. есть size

6. Какова алгоритмическая сложность BigO notaion поиска по индексу в LinkedList?
O(n/2) -> перебор всех элеметов, но сначала можем определить с начала или с конца перебирать, т.к. есть size

7. Какова алгоритмическая сложность BigO notaion удаления из LinkedList?
O(1) - само удаление происходит за константное время, перезаписываются ссылки у соседних нод друг на друга.

8. Почему коллекции работают только с ссылочными типами данных?
Коллекции работают только с дженерик ипами данных, а это всегда не примитивы. Дженерики не поддерживают примитивы.
Одна из причин, почему дженерики не работают с примитивами - нужно обращаться в одно и то же место памяти,
а примитивы не всегда в хипе.

9. Какой List эффективнее если надо удалять элементы из начала, середины, конца списка?
ArrayList - если удаляем с начала, то надо передвинуть все элементы O(n)
ArrayList - если удаляем из середины, то надо передвинуть половину элементов O(n/2) -> O(n)
ArrayList - если удаляем последний элемент O(1)
LinkedList - для удаления из середины O(n), так как надо сначала найти этот элемент
LinkedList - первый и последний элемент O(1) - удаляем за константное время

10. Можно ли создать List в котором нельзя менять объекты?
Сама изменяесть объктов зависит именно от объектов.
Для создания List-а из которого нельзя удалять элементы и в который нельзя добавлять элементы через
Collections.unmodifiableList() для java 8 и ниже, для более новых версий можноьприменять List.of() -
реализован через паттерн декоратор, который переопределяет часть методов, которые могут производить изменения,
бросает OperationNotSupportedException

11. Что вы знаете о классе Collections?
Класс, который не имеет своих реализаций - final класс, но в нём большое количество статических методов. Эти методы
расширяют возможности работы с коллекциями, которые не предусмотрены в интерфейсе Collection. Такая реализация связана с
обратной совместимостью, не стали расширять интерфейс, а создали новый класс для работы новых методов. Было актуально
до 8 java, пока не появились дефолтные методы в интерфесах, когда можно задать метод по умолчанию и переопределить
по необходимости.
Данные класс позволяет создавать неизменяемые коллекции, создавать из перечислений, сортировать

12. Зачем может пригодиться Collections.emptyList()?
Инициализирует пустую коллекцию класса EmptyList. Нужен для оптимизации, чтобы не создавать новые листы, реализован с
помощью паттерна синглетон и невозможно в него ничего добавить или удалить. Например возвращается из БД, если ничего не
нашли, чтобы потом не обрабатывать NPE.

13. Чем удобна форма List<String> list = new ArrayList<>()?
List - это интерфейс и мы можем проинициализировать его любым классом, который реализует этот интерфейс.
Это низкая связанность, можем отвязаться от конкретной реализации.

14. Чем потокобезопасные коллекции отличаются от непотокобезопасных?
Большинство операций в Java не атомарные, применяются в несколько действий. При многопоточно обращении к одному ресурсы
изменения могут потяряться (Отсутствие состоянии гонки).
1) Для того, чтобы исключить эти проблемы мы можем использовать синхронизацию synchronized List, synchronized Set,
synchronized Map - все методы этих коллекций синхронизированны. Внутрь такой коллекции может зайти только один тред,
остальные ожидают освобождения монитора.
2) в пакете Concurrency содержаться специфические коллекция, которые не блокируют все методы, а позволяют работать части методов синхронно

15. Что такое Comparable и Comparator?
Comparable - функциональный интерфейс, может быть реализован внутри класса, нужно переопределить метод int compareTo()
- сравнение двух объектов, возвращает -1,0 или 1.
Comparator - интерфейс, который не наследуется классами, а позволяет создавать своё собственный Comparator.
Comparable - удобно использовать с собственно написанными классами, если используем классы из библиотеки,
которые мы не можем изменить, применяем Comparator, передавая ему правила сравнения двух объектов.
//todo рассмотреть примеры использования Comparable и Comparator, можно сделать на Stream API

16. Расскажите как работает HashMap? Почему в HashMap быстрый поиск по ключу?
Key-Value
Map не является наследником интерфейса Collection, но класс Collections имеет методы работы с Map наравне с наследниками Collection.
Map - ключ - значение. Реализация Хэш-таблицы.
HashMap - массив объектов, равная 16 элемкнтам (бакетам). Бакет в которое кладём значение вычисляется с помощью
функции hashCode() - возвращает целое интовое значение, которое дальше делится на количество бакетов, а остаток от
деления, это как раз индекс нашего бакета, внутри бакета хранится односвязный список (не линкед лист!), и методок equals,
найти наше значение. При достижении определённого количества элементов в бакете 7-8 //todo уточнить кол-во элементов
происходит перестроение в дерево. Поиск по односвязанному списку O(n), поиск по дереву O(logn).
Если элементов в HashMap становится много (loadFactor?), мапа удваивается - становится 32 элемента и элементы
перераспределяются согласно хэш-коду в свои бакеты.
Чтобы сложность поиска не росла:
1) У нас правильно должен быть переопределён хэш-код у объекта
2) После обычного хэширования, происходит ещё одно рехэширования, для более плавного распределения по бакетам
Ключу - уникальный и ему нужно корректно переопределить метод equals, чтобы корректно устанавливать соответствие ключей,
второе условие, это неизменяемость ключа, иначе мы не сможем найти значение
//todo внести дополнения из лекции по Алгоритмам и структурам данных

17. Что такое и как устроен Set?
Множество уникальных элементов, предполагается, что каждый элемент представлен в единственном экземпляре, требования к
сету, такие же как к ключу в мапе. В Java реализован как аналогичная мапе с константным значением value.
Для потокобезовасного сета, млжно использовать потокобезопасный мап, засовывая в value , константный объект

18. Что такое итератор, зачем нужен? Чем Iterator отличается от ListIterator?
Специфичный интерфейс, который позволяет обходить коллекцию, все коллекции наследуются от итератора. Итератор может
двигаться только вперёд. ListIterator реализуется только в листах и может двигаться и вперёд и назад
//todo добавить примеры работы с Итератором