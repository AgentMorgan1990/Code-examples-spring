ORM (Object-Relational Mapping) - технология объектно-реляционного отображения.
Эта технология, дает возможность работать с таблицами БД в терминах классов и, наоборот, преобразовывать значения полей
классов в данные, пригодные для хранения в БД.

JPA (Java Persistence API) является спецификацией (стандартом), в которой определен набор интерфейсов и аннотаций.
Все эти интерфейсы и аннотации находятся внутри пакета «java.persistence».

Существует несколько распространенных реализаций JPA: «Hibernate», «EclipseLink», «Toplink». Существуют также
расширения JPA, такие как «Spring Data JPA».

EntityManager – это интерфейс, который обеспечивает основные действия, такие, как: выборка, добавление и удаление записи,
управление транзакциями т.д. В Hibernate используется наследник EntityManager - Session.

EntityManagerFactory – это фабричный класс, который создает и управляет несколькими экземплярами «EntityManager».
В Hibernate используется наследник EntityManagerFactory -SessionFactory.

Persistence – класс, который содержит статические методы для создания «EntityManagerFactory». Данный класс можно
рассматривать как главную входную точку в функциональность JPA, но непосредственно он используется редко, т.к.
существует множество более удобных методов работы с JPA.

EntityTransaction – интерфейс, который используется для управления транзакциями. Для каждого «EntityManager» создается
отдельный экземпляр «EntityTransaction» через метод «getTransaction». Entity – это объекты-сущности, которые
соответствуют таблицам базы данных.

Query - это интерфейс, который используется для получения записей из базы данных.

DAO – data access object

Сущность — это объект, которым управляет класс EntityManager, относящийся к Hibernate. Чтобы объекты класса являлись
сущностями, должны выполняться следующие условия:
1) Наличие аннотации @Entity;
2) Наличие поля, помеченного аннотацией @Id, в котором будет храниться уникальный идентификатор сущности;
3) Наличие конструктора без аргументов (конструктора по-умолчанию) с модификатором доступа protected или public.
Допускается объявление перегруженных конструкторов;
4) Отсутствие модификатора final в объявлении класса;
5) Отсутствие final в полях, ссылающихся на другие сущности, и в их геттерах;
6) Класс сущность должен быть верхнеуровневым классом. Перечисления и интерфейсы не могут быть сущностями;
7) Сущностями могут являться как обычные классы, так и абстрактные;
8) Доступ к полям сущности должен осуществляться через геттеры/сеттеры, сами поля не должны быть public;

Если нет необходимости в отображении какого-либо поля, необходимо пометить его аннотацией @Transient.

Важно отметить, что объект становится объектом-сущностью только после сохранения в базе данных. Кроме того, любой
объект-сущность должен иметь свой уникальный идентификатор. Значение может инжектироваться в поле id объекта-сущности
после его сохранения. Для этого необходимо использовать аннотацию @GeneratedValue. В зависимости от механизма генерации
значений id в базе данных, атрибуту strategy аннотации @GeneratedValue присваиваются различные значения из перечисления GenerationType.
Атрибут strategy может иметь следующие значения:

1) GenerationType.SEQUENCE — говорит о том, что значение id будет генерироваться с помощью sequence-генератора,
созданного разработчиком в базе данных. При использовании данной стратегии необходимо дополнительно указывать имя
генератора в атрибуте name аннотации @GeneratedValue;

2) GenerationType.IDENTITY — указывает поставщику постоянства, что значение id необходимо получать непосредственно из
столбца «id» таблицы, в которую мэппится данный объект-сущность;

3) GenerationType.AUTO — предоставлялет Hibernate возможность самостоятельно выбрать стратегию для получения id, исходя
из используемой СУБД;

4) GenerationType.TABLE — говорит о том, что для получения значения id необходимо использовать определенную таблицу в БД,
содержащую набор чисел.

Оптимальный подход — использование GenerationType.IDENTITY. Аннотация говорит Hibernate о том, что после сохранения
объекта в базе данных необходимо получить значение из столбца, на который отображается атрибут id, и присвоить его
объекту-сущности. А каким образом в этом столбце появится значение после вставки строки с информацией об объекте,
остается на совести разработчика. Данный подход удобен при использовании СУБД PostgreSQL, в которой такому столбцу можно
задать тип serial — и СУБД будет автоматически генерировать значения для данного столбца после вставки строки.

Контекст постоянства
Этот контекст представляет собой набор сущностей, которые управляются Hibernate в данный момент. Все управление сущностями
возлагается на менеджер сущностей — EntityManager, или Session в случае Hibernate. Он обладает полным набором CRUD-операций.
Результат операции никак не отразится на базе данных, пока не будет произведена фиксация транзакции.
Данные операции вызываются следующими методами:

persist(Object obj) - благодаря этому методу сущность становится управляемой Hibernate и заносится в контекст постоянства

detach(Object obj) - удаляет сущность obj из контекста постоянства (но не из БД), и объект перестает находиться под
управлением Hibernate;

refresh(Object obj) — синхронизирует сущность obj c БД. Ее поля будут иметь те значения, которые находились в столбцах
строки БД на момент применения данного метода.

Жизненный цикл JPA-сущностей
Сущности в JPA могут находиться в нескольких возможных состояниях переход между которыми определяется жизненным циклом.

После создания объекта сущности оператором new сущность находится в статусе «Transient», на этом этапе это обычный класс
никак не связанный с JPA. Для того чтобы сущность попала под управление «EntityManager», нужно вызывать метод «persist()».
После этого класс сущности переходит в состояние «Persistent». Следует отметить, что при вызове метода persist() JPA
предполагает, что сущности с таким идентификатором не существует. Под идентификатором понимается поле с аннотацией @Id
из класса сущности. Вывод сущности из управления происходит в тот момент, когда ей присваивается статус «detached», это
происходит в момент выполнения метода «commit()» объекта «EntityTransaction», или метода «close()» объекта «EntityManager».
При использовании аннотаций для управления транзакциями эти действия происходят автоматически.

JPQL
Набор методов CRUD-класса EntityManager ограничивает возможности по манипулированию сущностями. Например, метод find()
позволяет искать сущность только по идентификатору. Для создания более гибких запросов нужно использовать другие механизмы:

1) Запросы с использованием JPQL (Java Persistence Query Language) — объектно-ориентированный язык запросов, который
описан в спецификации JPA. В отличие от SQL, он оперирует сущностями на уровне кода, а в дальнейшем поставщик постоянства
транслирует эти запросы в SQL-запросы к БД;

2) Запросы с использованием HQL (Hibernate Query Language) — аналогичен JPQL, но используется только в Hibernate;

3) Запросы с использованием CRUD-методов;

4) Запросы с использованием Criteria API — запросы, которые последовательно формируются с помощью объектов и методов.

5) Запросы с использованием native SQL

Стоит отметить, что все языки запросов очень похожи на SQL. Рассмотрим синтаксис языка запросов JPQL, который основан на
HQL и позиционируется как более новая и стандартизованная версия этого языка.

Главное отличие JPQL от SQL состоит в том, что JPQL-запросы манипулируют сущностями, то есть объектами классов. Самый
простой JPQL-запрос, который делает выборку всех объектов-сущностей класса Article из базы данных, выглядит так:

SELECT a FROM Article a
оператор FROM указывает на класс (в данном случае — класс Article), выборку объектов которого необходимо сделать из
соответствующей ему таблицы в базе данных;
в блоке оператора FROM указывается псевдоним класса (в данном случае — a).

Если необходимо применить определенный критерий поиска, то запрос будет выглядеть так:

SELECT a FROM Article a WHERE a.id = 2
В данном случае псевдоним a используется для доступа к атрибутам класса. Возвращать можно не только объекты, но и
атрибуты класса. Запрос, возвращающий атрибуты объекта, может выглядеть следующим образом:

SELECT a.firstname, a.lastname FROM Author a

Если используется привязка параметров, запрос может быть таким:
SELECT a.firstname, a.lastname FROM Author a WHERE a.id = ?1

В случае именованных параметров:
SELECT a.firstname, a.lastname FROM Author a WHERE a.id = :id

Можно указать поставщику постоянства, что необходимо создать объекты из возвращаемых из БД значений. Например:
SELECT NEW com.example.hibernate.Person(a.firstname, a.lastname) FROM Author a
Класс Person не обязан являться сущностью, но должен содержать конструктор с указанной в запросе сигнатурой.

Динамические запросы
createQuery(String jpqlString) — метод, принимающий строку JPQL-запроса и возвращающий объект класса Query;
createNamedQuery(String name) — метод для именованных запросов, принимающий их названия и возвращающий объекты класса Query;
createNativeQuery(String sqlString) — метод для запросов с использованием SQL, возвращает объект класса Query и других.

Эти методы имеют свои перегруженные аналоги, принимающие дополнительный параметр типа Class или Class<T>, которые
помогают избежать лишних преобразований типов.

Все вышеперечисленные методы не обеспечивают выполнение запроса как такового — для этого необходимо использовать:
1) getSingleResult() — для получения одиночного объекта в качестве конечного результата запроса;
2) getResultList() — для получения коллекции объектов как конечного результата запроса;

Осуществление запроса, возвращающего коллекцию:
List<Author> authors = em.createQuery("SELECT a FROM Author a", Author.class).getResultList();

Осуществление запроса, возвращающего одиночный результат:
Author author = em.createQuery("SELECT a FROM Author a WHERE a.id = 1", Author.class).getSingleResult();


Именованные запросы
Именованные запросы более производительны, чем динамические. Это связано с тем, что преобразование JPQL-запроса в SQL
происходит сразу после запуска приложения. Чтобы выполнить именованный запрос, в классе, к которому он будет
осуществляться, необходимо объявить аннотацию @NamedQuery, содержащую следующие атрибуты:
1) name — название именованного запроса;
2) query — JPQL-строка запроса.
Можно объявлять несколько именованных запросов с помощью множественной аннотации @NamedQueries.
Объявление именованных запросов:

@Entity
@Table(name="author")
@NamedQueries({
@NamedQuery(name = "Author.findAll", query = "SELECT a FROM Author a"),
@NamedQuery(name = "Author.findById", query = "SELECT a FROM Author a WHERE a.id = :id")
})
public class Author{}

В данном листинге показан пример объявления двух именованных запросов: Author.findAll для получения всех авторов;
Author.findById (аналог метода find класса EntityManager), использующий именованные параметры.
Формат названий именованных запросов рекомендует употреблять имя класса в качестве префикса, а само название отражает
операцию и критерий. В коде использование именованных запросов будет выглядеть так:
List<Author> authors = em.createNamedQuery("Author.findAll", Author.class).getResultList();
Author author = em.createNamedQuery("Author.findById", Author.class).setParameter("id", 1).getSingleResult();